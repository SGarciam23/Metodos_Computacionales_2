import os
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks
from scipy.interpolate import interp1d

# Ruta base
ruta_base = r"/Taller-#1/mammography_spectra.zip"

# Parámetros de limpieza
puntos_vecinos = 3
prom_rel = 0.05
margen_zoom_keV = 1.0

# Diccionario para almacenar datos por elemento
residuales = {"W": [], "Rh": [], "Mo": []}
rangos_picos = {"W": [], "Rh": [], "Mo": []}

# Procesar datos
for subcarpeta in os.listdir(ruta_base):
    ruta_subcarpeta = os.path.join(ruta_base, subcarpeta)
    if not os.path.isdir(ruta_subcarpeta):
        continue

    # Detectar elemento por nombre de carpeta
    if "W" in subcarpeta:
        elemento = "W"
    elif "Rh" in subcarpeta:
        elemento = "Rh"
    elif "Mo" in subcarpeta:
        elemento = "Mo"
    else:
        continue

    for archivo in os.listdir(ruta_subcarpeta):
        if not archivo.endswith(".dat"):
            continue

        # Leer datos originales
        datos = np.loadtxt(os.path.join(ruta_subcarpeta, archivo), encoding='latin1')
        energia, conteo = datos[:, 0], datos[:, 1]

        # --- Limpiar picos ---
        picos, _ = find_peaks(conteo, prominence=prom_rel * np.max(conteo))
        mascara = np.ones_like(conteo, dtype=bool)
        for p in picos:
            ini = max(0, p - puntos_vecinos)
            fin = min(len(conteo), p + puntos_vecinos + 1)
            mascara[ini:fin] = False

        energia_sin_picos = energia[mascara]
        conteo_sin_picos = conteo[mascara]

        # --- Aproximar continuo ---
        kind_interp = "cubic" if len(energia_sin_picos) >= 4 else "linear"
        interp_func = interp1d(energia_sin_picos, conteo_sin_picos, kind=kind_interp, fill_value="extrapolate")
        continuo_aprox = interp_func(energia)

        # --- Calcular residual ---
        residual = conteo - continuo_aprox

        # --- Detectar picos en residual ---
        pidx, _ = find_peaks(residual, prominence=0.01 * np.max(residual) if np.max(residual) > 0 else 1e9)
        if len(pidx) == 0:
            continue

        emin = energia[pidx].min() - margen_zoom_keV
        emax = energia[pidx].max() + margen_zoom_keV

        residuales[elemento].append((energia, residual, archivo))
        rangos_picos[elemento].append((emin, emax))

# --- Graficar ---
fig, axs = plt.subplots(3, 1, figsize=(10, 12))
orden = ["W", "Rh", "Mo"]
titulos = {"W": "Tungsteno (W)", "Rh": "Rodio (Rh)", "Mo": "Molibdeno (Mo)"}

for i, elem in enumerate(orden):
    ax = axs[i]
    if len(residuales[elem]) == 0:
        ax.set_title(f"{titulos[elem]} — sin picos detectables")
        ax.set_xlabel("Energía (keV)")
        ax.set_ylabel("Residual (picos)")
        continue

    # Zoom global para ese elemento
    emin_global = min(e for e, _ in rangos_picos[elem])
    emax_global = max(e for _, e in rangos_picos[elem])

    for energia, residual, nombre in residuales[elem]:
        mask = (energia >= emin_global) & (energia <= emax_global)
        ax.plot(energia[mask], residual[mask], alpha=0.7, label=nombre.replace(".dat", ""))

    ax.set_title(f"Picos aislados — {titulos[elem]}")
    ax.set_xlim(emin_global, emax_global)
    ax.set_xlabel("Energía (keV)")
    ax.set_ylabel("Residual (cuentas)")
    ax.legend(ncol=4, fontsize=8)

plt.tight_layout()
plt.savefig("3.a.pdf")
plt.show()

import os
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks
from scipy.optimize import curve_fit
from numpy.polynomial import Polynomial


# Configuración general

ruta_base = r"/content/mammography_spectra"

prom_rel_continuo = 0.05
puntos_vecinos = 3

# Detección y ajuste en el residual
prom_rel_residual = 0.01
ventana_ajuste_keV = 1.5

# Grado máximo del polinomio del continuo (adaptativo si hay pocos puntos)
grado_max = 4

# Modelo gaussiano + offset
def gauss_con_offset(x, A, mu, sigma, c):
    return A * np.exp(-(x - mu)*2 / (2.0 * sigma*2)) + c


# Resultados
resultados = {
    "W": {"volt": [], "altura": [], "fwhm": []},
    "Rh": {"volt": [], "altura": [], "fwhm": []},
    "Mo": {"volt": [], "altura": [], "fwhm": []}
}

# Recorrer carpetas/archivos
for subcarpeta in os.listdir(ruta_base):
    ruta_subcarpeta = os.path.join(ruta_base, subcarpeta)
    if not os.path.isdir(ruta_subcarpeta):
        continue

    # Detectar elemento
    if "W" in subcarpeta:
        elemento = "W"
    elif "Rh" in subcarpeta:
        elemento = "Rh"
    elif "Mo" in subcarpeta:
        elemento = "Mo"
    else:
        continue

    for archivo in os.listdir(ruta_subcarpeta):
        if not archivo.endswith(".dat"):
            continue

        # Extraer voltaje del nombre del archivo
        volt_str = "".join(ch for ch in archivo if ch.isdigit())
        if not volt_str:
            continue
        voltaje = int(volt_str)

        # Leer espectro
        # Use latin1 encoding as in previous cells that succeeded
        datos = np.loadtxt(os.path.join(ruta_subcarpeta, archivo), encoding='latin1')
        energia, conteo = datos[:, 0], datos[:, 1]

        # (1) Limpiar picos del continuo (sin interpolar)
        if np.max(conteo) <= 0:
            continue

        picos_cont, _ = find_peaks(conteo, prominence=prom_rel_continuo * np.max(conteo))
        mascara = np.ones_like(conteo, dtype=bool)
        for p in picos_cont:
            ini = max(0, p - puntos_vecinos)
            fin = min(len(conteo), p + puntos_vecinos + 1)
            mascara[ini:fin] = False

        e_sin = energia[mascara]
        c_sin = conteo[mascara]

        # Asegurar suficientes puntos para ajustar un polinomio
        if len(e_sin) < 3:
            # Demasiado pocos puntos para estimar continuo de forma fiable
            continue

        # Grado adaptativo (no mayor que grado_max ni que len(e_sin)-1)
        grado = min(grado_max, max(1, len(e_sin) - 1))

        # Ajuste polinomial estable (sin interpolación)
        # Polynomial.fit mapea internamente el dominio para estabilidad numérica
        try:
            poly = Polynomial.fit(e_sin, c_sin, deg=grado)
            continuo = poly(energia)
        except Exception:
            # Si el ajuste falla por mala condición, intentamos con grado menor
            exito = False
            for g in range(min(grado-1, 3), 0, -1):
                try:
                    poly = Polynomial.fit(e_sin, c_sin, deg=g)
                    continuo = poly(energia)
                    exito = True
                    break
                except Exception:
                    continue
            if not exito:
                continue

        # (2) Residual (picos)
        residual = conteo - continuo
        if np.max(residual) <= 0:
            continue

        pidx, _ = find_peaks(residual, prominence=prom_rel_residual * np.max(residual))
        if len(pidx) == 0:
            continue

        # Pico mayor
        idx_max = pidx[np.argmax(residual[pidx])]
        mu_ini = energia[idx_max]
        A_ini = residual[idx_max]
        c_ini = np.median(residual)

        # Ventana local para el ajuste
        mask_fit = (energia >= mu_ini - ventana_ajuste_keV/2) & (energia <= mu_ini + ventana_ajuste_keV/2)
        xfit = energia[mask_fit]
        yfit = residual[mask_fit]

        if len(xfit) < 6:
            # ampliar por índices si la ventana quedó muy estrecha
            i0 = max(0, idx_max - 5)
            i1 = min(len(energia), idx_max + 6)
            xfit = energia[i0:i1]
            yfit = residual[i0:i1]
        if len(xfit) < 4:
            # demasiados pocos puntos para fit
            continue

        # (3) Ajuste Gaussiano del pico mayor
        try:
            popt, _ = curve_fit(
                gauss_con_offset, xfit, yfit,
                p0=[A_ini, mu_ini, 0.30, c_ini],
                bounds=([0.0, mu_ini - 1.0, 0.05, -np.inf],
                        [np.inf, mu_ini + 1.0, 2.00,  np.inf]),
                maxfev=10000
            )
            A, mu, sigma, c0 = popt
            fwhm = 2.0 * np.sqrt(2.0 * np.log(2.0)) * sigma

            resultados[elemento]["volt"].append(voltaje)
            resultados[elemento]["altura"].append(A)
            resultados[elemento]["fwhm"].append(fwhm)
        except Exception:
            # Si el ajuste falla, saltamos este espectro
            continue

# Graficar resultados
fig, axs = plt.subplots(1, 2, figsize=(12, 5))
colores = {"W": "C0", "Rh": "C1", "Mo": "C2"}

# Altura vs Voltaje
for elem, color in colores.items():
    v = np.array(resultados[elem]["volt"])
    A = np.array(resultados[elem]["altura"])
    if len(v) == 0:
        continue
    idx = np.argsort(v)
    axs[0].plot(v[idx], A[idx], 'o-', label=elem)
axs[0].set_title("Altura del pico mayor vs Voltaje")
axs[0].set_xlabel("Voltaje (kV)")
axs[0].set_ylabel("Altura (cuentas)")
axs[0].legend()

# FWHM vs Voltaje
for elem, color in colores.items():
    v = np.array(resultados[elem]["volt"])
    w = np.array(resultados[elem]["fwhm"])
    if len(v) == 0:
        continue
    idx = np.argsort(v)
    axs[1].plot(v[idx], w[idx], 'o-', label=elem)
axs[1].set_title("FWHM del pico mayor vs Voltaje")
axs[1].set_xlabel("Voltaje (kV)")
axs[1].set_ylabel("FWHM (keV)")
axs[1].legend()

plt.tight_layout()
plt.savefig("3.b.pdf")
plt.show()
