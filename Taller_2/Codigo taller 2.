
#punto 2.

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.fft import fft, fftfreq
from scipy.signal import find_peaks
from scipy.ndimage import gaussian_filter1d

# 2.a. Arreglar datos

# Cargar el archivo, ignorando comentarios (#) y usando el delimitador correcto (;)

df = pd.read_csv("/SN_d_tot_V2.0.csv", sep=",", comment="#")

# Columnas según SILSO (seleccionar las primeras 5 columnas)

df = df.iloc[:, :5]
df.columns = ["year", "month", "day", "decimal_date", "sunspots"]

# Reemplazar -1 por NaN y luego interpolar linealmente

df["sunspots"] = df["sunspots"].replace(-1, np.nan)
df["sunspots"] = df["sunspots"].interpolate(method="linear")

# 2.b. FFT y periodo

y = df["sunspots"].values
N = len(y)

# Serie de tiempo: un punto por día

t = np.arange(N)

# FFT (centrada en la media)

Y = fft(y - np.mean(y))
freqs = fftfreq(N, d=1)   # en ciclos por día

# Solo frecuencias positivas
mask = freqs > 0
freqs = freqs[mask]
power = np.abs(Y[mask])**2

# Limitar a ciclos entre 8 y 16 años (≈3000 a 6000 días)
min_freq = 1/6000
max_freq = 1/3000
relevant_freqs_mask = (freqs >= min_freq) & (freqs <= max_freq)

# Encontrar el máximo en ese rango
peak_idx = np.argmax(power[relevant_freqs_mask])
original_indices_of_relevant_freqs = np.where(relevant_freqs_mask)[0]
peak_freq_original_idx = original_indices_of_relevant_freqs[peak_idx]

f_peak = freqs[peak_freq_original_idx]
period_days = 1 / f_peak

# Guardar en archivo de texto
with open("2.b.txt", "w") as f:
    f.write(f"{period_days:.2f} días (~{period_days/365:.2f} años)\n")

# Filtrado pasa bajas
filtered = gaussian_filter1d(y, sigma=500)

plt.figure(figsize=(12,6))
plt.plot(df["decimal_date"], y, lw=0.3, label="Datos originales")
plt.plot(df["decimal_date"], filtered, lw=2, label="Filtrado (Gauss)")
plt.xlabel("Fecha decimal (años)")
plt.ylabel("Número de manchas solares")
plt.legend()
plt.tight_layout()
plt.savefig("2.b.data.pdf")
plt.close()

# Máximos locales
# distancia mínima entre máximos ~3000 días (~8 años)
peaks, _ = find_peaks(filtered, distance=3000)
peak_times = df["decimal_date"].iloc[peaks].values
peak_values = filtered[peaks]

plt.figure(figsize=(10,6))
plt.scatter(peak_times, peak_values, color="red", label="Máximos locales")
plt.plot(df["decimal_date"], filtered, color="blue", lw=1, label="Filtrado")
plt.xlabel("Fecha decimal (años)")
plt.ylabel("Número de manchas solares (filtrado)")
plt.title("Máximos locales del ciclo solar")
plt.legend()
plt.tight_layout()
plt.savefig("2.b.maxima.pdf")
plt.close(



#Punto 5

import numpy as np
import matplotlib.pyplot as plt
from scipy import ndimage as ndi
from numpy.fft import rfft, irfft, rfftfreq

# --- Paths ---
data_path = "/mnt/data/tomography_data/tomography_data/3.npy"
out_unfiltered = "/mnt/data/4_unfiltered.png"
out_filtered = "/mnt/data/4.png"

# --- Load projections ---
projections = np.load(data_path)  # shape (n_angles, n_detectors) ?
print("Shape:", projections.shape)

# Si está al revés, transponer
if projections.shape[0] < projections.shape[1]:
    projections = projections.T
    print("Transposed:", projections.shape)

n_angles, n_detectors = projections.shape
rows = n_detectors
angles = np.linspace(0.0, 180.0, n_angles, endpoint=False)

# --- High-pass filter (ramp + Hann) ---
freqs = rfftfreq(n_detectors, d=1.0)
ramp = np.abs(freqs)
hann = 0.5 - 0.5 * np.cos(2 * np.pi * np.arange(len(ramp)) / (len(ramp) - 1))
ramp_windowed = ramp * hann

filtered = np.empty_like(projections, dtype=float)
for i in range(n_angles):
    p = projections[i].astype(float)
    P = rfft(p)
    Pf = P * ramp_windowed
    filtered[i] = irfft(Pf, n=n_detectors)

# --- Reconstrucción SIN filtro ---
accum_unfiltered = np.zeros((rows, rows))
for angle, signal in zip(angles, projections):
    imagen_rotada = ndi.rotate(
        np.tile(signal[:, None], rows).T,
        angle,
        reshape=False,
        mode="reflect"
    )
    accum_unfiltered += imagen_rotada

# --- Reconstrucción CON filtro ---
accum_filtered = np.zeros((rows, rows))
for angle, signal in zip(angles, filtered):
    imagen_rotada = ndi.rotate(
        np.tile(signal[:, None], rows).T,
        angle,
        reshape=False,
        mode="reflect"
    )
    accum_filtered += imagen_rotada

# --- Normalizar ---
def normalize(img):
    img = img - img.min()
    return img / img.max() if img.max() > 0 else img

accum_unfiltered = normalize(accum_unfiltered)
accum_filtered = normalize(accum_filtered)

# --- Guardar imágenes ---
plt.imsave(out_unfiltered, accum_unfiltered, cmap="gray", origin="lower")
plt.imsave(out_filtered, accum_filtered, cmap="gray", origin="lower")

print("Reconstrucciones guardadas en:")
print(" -", out_unfiltered)
print(" -", out_filtered)
