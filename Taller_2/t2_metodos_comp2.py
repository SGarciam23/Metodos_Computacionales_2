# -*- coding: utf-8 -*-
"""T2_Metodos_Comp2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m5Uq0gh7Zy-mb-IwHnd48e8yAgjsjQ1G
"""

# PUNTO 3

import numpy as np
from PIL import Image
from scipy.fft import fft2, ifft2, fftshift, ifftshift
import matplotlib.pyplot as plt
from skimage.feature import peak_local_max

# ======================================================
# 3.a.Desenfoque
# ======================================================

def desenfoque_gaussiano(imagen_path, A):
  imagen = np.array(Image.open(imagen_path).convert("RGB"), dtype=float)
  imagen_borrosa = np.zeros_like(imagen)

  for c in range(3):
    canal = imagen[:, :, c]
    # FFT centrada
    F = fft2(canal)
    F_shift = fftshift(F)

    # Filtro gaussiano
    h, w = canal.shape
    y, x = np.indices((h, w))
    cx, cy = w // 2, h // 2
    gauss = np.exp(-((x - cx)**2 + (y - cy)**2) / (2 * A**2))

    # Filtrado en frecuencia
    F_filtrado = F_shift * gauss

    # Transformada inversa
    imagen_borrosa[:, :, c] = np.abs(ifft2(ifftshift(F_filtrado)))

  Image.fromarray(np.uint8(imagen_borrosa)).save("3.a.jpg")

desenfoque_gaussiano("miette.jpg", 20)

# ======================================================
# 3.b.a.Ruido Pato
# ======================================================

def eliminar_ruido_periodico(ruta_imagen_entrada, percentil=99.9, radio=3):
  imagen = Image.open(ruta_imagen_entrada).convert('L')
  imagen_array = np.array(imagen, dtype=float)

  F = fft2(imagen_array)
  F_shift = fftshift(F)
  magnitud = np.abs(F_shift)
  mag_log = np.log1p(magnitud)

  filas, columnas = imagen_array.shape
  centro = (filas // 2, columnas // 2)
  umbral = np.percentile(mag_log, percentil)
  coords = peak_local_max(
      mag_log,
      min_distance=10,
      threshold_abs=umbral,
      exclude_border=False
  )

  coords_filtradas = [
      (int(y), int(x)) for y, x in coords
      if (abs(y - centro[0]) > 5 or abs(x - centro[1]) > 5)
  ]

  for (y, x) in coords_filtradas:
    for dy in range(-radio, radio + 1):
      for dx in range(-radio, radio + 1):
        yy = (y + dy) % filas
        xx = (x + dx) % columnas
        sy = (2 * centro[0] - yy) % filas
        sx = (2 * centro[1] - xx) % columnas
        F_shift[yy, xx] = 0
        F_shift[sy, sx] = 0


  F_ishift = ifftshift(F_shift)
  imagen_sin_ruido = np.abs(ifft2(F_ishift))

  imagen_norm = 255 * (imagen_sin_ruido - imagen_sin_ruido.min()) / np.ptp(imagen_sin_ruido)
  imagen_norm = np.uint8(imagen_norm)


  Image.fromarray(imagen_norm).save("3.b.a.jpg")

eliminar_ruido_periodico("p_a_t_o.jpg", percentil=99.9, radio=5)

# ======================================================
# 3.b.b.Ruido Gato
# ======================================================

def detectar_picos(fft_magnitud, umbral):
  h, w = fft_magnitud.shape
  cy, cx = h // 2, w // 2
  coords = []
  for y in range(h):
    for x in range(w):
      if abs(y - cy) < 5 and abs(x - cx) < 5:
        continue  # no tocar la componente DC
      if fft_magnitud[y, x] > umbral:
        coords.append((y, x))
  return coords

def eliminar_ruido_gato(imagen_path, factor_umbral):
  imagen = np.array(Image.open(imagen_path).convert("L"), dtype=float)
  F = fft2(imagen)
  F_shift = fftshift(F)
  magnitud_log = np.log1p(np.abs(F_shift))

  umbral = magnitud_log.mean() * factor_umbral
  picos = detectar_picos(magnitud_log, umbral)

  h, w = imagen.shape
  cy, cx = h // 2, w // 2
  for (y, x) in picos:
    F_shift[y, x] = 0
    sy = (2*cy - y) % h
    sx = (2*cx - x) % w
    F_shift[sy, sx] = 0

  imagen_sin_ruido = np.abs(ifft2(ifftshift(F_shift)))
  imagen_sin_ruido = np.clip(imagen_sin_ruido, 0, 255)
  Image.fromarray(np.uint8(imagen_sin_ruido)).save("3.b.b.png")

eliminar_ruido_gato("g_a_t_o.png", 5)